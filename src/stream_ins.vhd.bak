library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

entity stream_ins is
  port(
   clk_i : in std_logic;
   rst_i : in STD_LOGIC;
   start_cmd_i : in std_logic;
   stop_cmd_i : in std_logic;
   -- AVALON-ST IF
   sink_valid	: IN STD_LOGIC;
   sink_sop	: IN STD_LOGIC;
   sink_eop	: IN STD_LOGIC;
   --sink_real	: IN STD_LOGIC_VECTOR (15 DOWNTO 0);
   --sink_imag	: IN STD_LOGIC_VECTOR (15 DOWNTO 0);
   --sink_error	: IN STD_LOGIC_VECTOR (1 DOWNTO 0);
   source_ready	: out STD_LOGIC;
   sink_ready	: in STD_LOGIC;
   --source_error	: OUT STD_LOGIC_VECTOR (1 DOWNTO 0);
   source_sop	: OUT STD_LOGIC;
   source_eop	: OUT STD_LOGIC;
   source_valid	: OUT STD_LOGIC;
   --source_real	: OUT STD_LOGIC_VECTOR (15 DOWNTO 0);
   --source_imag	: OUT STD_LOGIC_VECTOR (15 DOWNTO 0);

   --buffer ctrl
   rd_o  : out std_logic;
   wr_init_o : out std_logic;
   rd_init_o : out std_logic;
   wr_init_done_i : in std_logic;
   wr_window_done_i : in std_logic;
   rd_samples_done_i : in std_logic;


   --output buffer ctrl
   result_wr_en_o : out std_logic;
   result_wr_addr_o : out std_logic_vector (9 downto 0)

  );
end stream_ins;

architecture rtl of stream_ins is

type state_type is (S0_IDLE,
                    S1_INIT,
                    S2_SEND_INIT_PACKET,
                    S1_WAIT_FOR_SAMPLES,
                    S2_SEND_PACKET,
                    S3_SOURCE_READY,
                    S4_GET_RESULTS);

signal state, next_state : state_type;
signal result_wr_addr_reg, result_wr_addr_next : unsigned(9 downto 0);

begin

-- Main state machine combinatorial logic for state transitions
CL: process(clk_i, state, start_cmd_i, stop_cmd_i, wr_init_done_i, wr_window_done_i, rd_samples_done_i, sink_valid, sink_ready, sink_sop, sink_eop)
begin
  --default output values
  next_state <= state;

case(state) is

  when S0_IDLE =>
    if (start_cmd_i ='1') then
      next_state <= S1_INIT;
    else
      next_state <= S0_IDLE;
    end if;

  when S1_INIT =>
    if (wr_init_done_i = '1' and sink_ready = '1') then
      next_state <= S2_SEND_INIT_PACKET;
    else
      next_state <= S1_INIT;
    end if;

  when S2_SEND_INIT_PACKET =>
    if (rd_samples_done_i = '1') then
      next_state <= S3_SOURCE_READY;
    else
      next_state <= S2_SEND_INIT_PACKET;
    end if;

  when S1_WAIT_FOR_SAMPLES =>
    if (wr_window_done_i = '1' and sink_ready = '1') then
      next_state <= S2_SEND_PACKET;
    else
      next_state <= S1_WAIT_FOR_SAMPLES;
    end if;

  when S2_SEND_PACKET =>
      if (rd_samples_done_i = '1') then
        next_state <= S3_SOURCE_READY;
      else
        next_state <= S2_SEND_PACKET;
      end if;

  when S3_SOURCE_READY =>
      if (sink_valid = '1' and sink_sop='1') then
        next_state <= S4_GET_RESULTS;
      else
            next_state <= S3_SOURCE_READY;
      end if;
  when S4_GET_RESULTS =>
        if (sink_valid='1' and sink_eop ='1') then
            if (stop_cmd_i = '1') then
              next_state <= S0_IDLE;
            else
                next_state <= S1_WAIT_FOR_SAMPLES;
            end if;
        else
            next_state <= S4_GET_RESULTS;
        end if;
  when OTHERS =>
            next_state <= S0_IDLE;

end case;



end process;


--OUTPUT assigments

--input buffer ctrl signals
rd_o <= '1' when (state = S2_SEND_INIT_PACKET or state = S2_SEND_PACKET) else '0';
rd_init_o <= '1' when (state = S2_SEND_INIT_PACKET) else '0';
wr_init_o <= '1' when (state = S1_INIT) else '0';


--Avalon IF output signals
source_valid <= '1' when (state = S2_SEND_INIT_PACKET or state = S2_SEND_PACKET or state = S3_SOURCE_READY) else '0';
source_sop <= '1' when (state =  S2_SEND_INIT_PACKET or state = S2_SEND_PACKET) else '0';
source_eop <= '1' when (state = S3_SOURCE_READY) else '0';
source_ready <= '1' when (state = S3_SOURCE_READY or state = S4_GET_RESULTS) else '0';

--otuput buffer ctrl signals
result_wr_en_o <= '1' when (state = S4_GET_RESULTS) else '0';
result_wr_addr_next <= result_wr_addr_reg + 1 when state = S4_GET_RESULTS else result_wr_addr_reg;
result_wr_addr_o <= std_logic_vector(result_wr_addr_reg(9 downto 0));

SEQ : process(clk_i, rst_i)
begin
  if (rst_i = '1') then
    state <= S0_IDLE;
    result_wr_addr_reg <=  (others => '0');
  elsif (clk_i'event and clk_i = '1') then
    state <= next_state;
    result_wr_addr_reg <= result_wr_addr_next;
  end if;
end process;




end rtl;
